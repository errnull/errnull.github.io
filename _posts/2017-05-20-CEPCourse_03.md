---
layout: post
title: 一份来自 iOS🙈 的零基础 After Effects CEP 教程 -- [ 3 ] CEP 构成详解
date: 2017-05-20 
tags:  Adobe-CEP   
---

<br><br>

上篇文章我们完成了第一个项目 -- HelloWorld。<br>
现在我们开始对一个 CEP 项目的构成进行详细解释：
<br><br><br>

### JSX 文件

“JSX 中写的是 Adobe 为旗下软件的提供的自动化脚本 -- ExtendScript。”<br>
它是可以在宿主应用中独立运行的，这也是我将它放在第一个讲的原因。

举个栗子：
![](/images/posts/jekyll/2017-05-14-CEPCourse_03-01.jpg)<br>
这个 [ENMetadataCleaner.jsx](https://github.com/yyued/ENMetadataCleaner) 是博主写的一个 “PSD 文件瘦身” 脚本，有兴趣的可以 [download](https://github.com/yyued/ENMetadataCleaner.git) 来看看。

其中：<br>

```
var mainDocument = app.activeDocument;
```

调用了宿主应用 (这里是 PS) 提供的 API 从 DOM 中获取当前 **app** 的 **activeDocument**。<br><br>

```
deleteDocumentAncestorsMetadata();
```
这个方法的实现也是通过宿主应用提供的 API 进行一些对宿主应用的操作，总的来说就是控制宿主应用去做事，通过 JSX 基本上可以实现所有的操作。<br>

完成对 JSX 的编辑后，我们只需要在宿主应用 (这里是 PS) 的菜单栏中选择：

```
「 文件 」——「 脚本 」——「 浏览 」
```

选中 JSX 文件，就可以跑起来啦。

你也可以使用一开始讲到的 [Adobe ExtendScript Toolkit CC](http://errnull.top/2017/05/CEPCourse_01/) 
![](/images/posts/jekyll/2017-05-12-CEPCourse_01-02.jpg)

只需要选择好宿主程序，在编辑框中写代码再点击运行即可。
你还可以在的 Toolkit 的 Data Browser 窗口实时查看宿主应用的 DOM，这可以让你查看对象中有什么成员：
![](/images/posts/jekyll/2017-05-14-CEPCourse_02-05.jpg)

比如前面提到的 **app.activeDocument**

关于 ExtendScript 的具体介绍，接下来会有一篇巨长的文章专门讲，这里就不再赘述。
<br><br><br><br>

### CEP 界面

从 HelloWorld 中不难看出，CEP 无非就是一个由 **HTML+CSS** 写的界面面板，加上用 **JavaScript** 响应事件，再用 **node.js**(CEP 本身有 node 环境) 去读写本地文件这三个模块构成的一个本地 Web 项目。
这里借用[浅藏的宝藏](http://nullice.com/archives/1622)博主画的一张关系图：<br><br>
![](/images/posts/jekyll/2017-05-14-CEPCourse_03-02.jpg)

从关系图可以看出，我们使用 **CSInterface.js** 充当连接宿主程序和 CEP 扩展的桥梁，通过
```
cs.evalScript("function()", callback);
```
来调用 JSX 中的方法从而控制宿主程序。
<br><br><br><br>

### CSXS/manifest.xml 文件

**manifest.xml** 里面有扩展的重要的配置信息，包括扩展名称、版本、在什么宿主中运行、入口文件、尺寸等等等，**manifest.xml** 只有宿主应用启动时载入，所以修改了 **manifest.xml** 只有重启宿主应用才会使修改生效。 **manifest.xml** 是一个 XML 文件，你可以用任何文本编辑器打开并编辑它，另外还可以使用 foxe 等 XML 编辑器更加直观的以树形列表查看和编辑。<br><br>
![](/images/posts/jekyll/2017-05-14-CEPCourse_03-03.jpg)

在 [Hello World](https://github.com/errnull/CEP-Demo.git) 的 manifest.xml 中，我写了部门注释，在这里我进行一次详细解释：<br><br>

<br><br>

#### 1.扩展

　<ExtensionManifest> 标签中的 ExtensionBundleId 属性定义的是这个扩展程序集的识别 ID ，之所以说是扩展程序集，因为一个 manifest.xml 可以定义多个子扩展，每个扩展集中的子扩展可以共用资源而在宿主应用的插件列表中有自己的位置。<br>
　每个子扩展的信息写在 <ExtensionList> 的 <Extension> 子标签中。每个扩展 ID 都需要是唯一的，所以常常使用前缀避免与其他开发者的扩展冲突如：com.yourName.xxxx、com.adobe.xxxx。<br><br>
　下面这个示例就定义了一个 ID 为 com.nullice.cep.devtest 的扩展集，并拥有 3 个子扩展：

```
<ExtensionManifest xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ExtensionBundleId="com.nullice.cep.devtest" ExtensionBundleVersion="1.0" Version="6.0"> <!-- MAJOR-VERSION-UPDATE-MARKER -->

<ExtensionList>
 <Extension Id="com.nullice.cep.devtest.c_1" Version="1.0"/> 
 <Extension Id="com.nullice.cep.devtest.c_2" Version="1.0"/> 
 <Extension Id="com.nullice.cep.devtest.c_3" Version="1.0"/> 
</ExtensionList>
```

<br><br>

#### 2.支持宿主版本

　<ExecutionEnvironment> 标签的子标签 <HostList> 中的 <Host> 定义了这个扩展集的所有程序可以在那些宿主和其对应版本中运行，比如：

```
<Host Name="PHSP" Version="14.0"/>
<Host Name="PHXS" Version="14.0"/>
```

　Name 属性是支持的宿主程序名， PHSP、PHXS 表示的是 PhotoShop ，Version 属性是限定宿主程序的版本，比如 PhotoShop CC2015 的版本是 16.0，除了限定在某个版本，还可以限定在一个区间，比如下面这个例子是限定运行在 11.0 到 99.9 之间的版本。

```
<Host Name="PHXS" Version="[11.0,99.9]"/>
```

这是各个 Adobe 程序与对应宿主 ID 还有各版本版本号的列表：
![](/images/posts/jekyll/2017-05-14-CEPCourse_03-04.jpg)

<br><br>

#### 3.扩展定义

　 **DispatchInfoList** 的子标签 **Extension** 中的 **DispatchInfo** 标签定义了扩展具体的各种属性。对应不同的子扩展，**DispatchInfoList** 可以有多个 **Extension** 标签。

**指定资源文件**

```
<Resources>    
  <MainPath>./index.html</MainPath>
  <ScriptPath>./jsx/Source1.jsx</ScriptPath>
</Resources>
```

　**MainPath** 指定的是主页面的 HTML 文化的位置， 这个文件就是 CEP 面板中的内容，在面板打开时第一个就会载入它。<br>
　**ScriptPath** 是指定扩展中会使用到的 JSX 文件的内容。（除了在这里指定还可以动态加载 JSX 文件，以后会详细说明）<br><br>

**生命周期**
**Lifecycle** 标签下的设置关于插件启动和可视的设定。

* 扩展可视
　<AutoVisible>true</AutoVisible>
设定扩展是否可视，值为 false 的话, 扩展就是没有界面的不可视扩展。（要让插件完全隐形的话，可以不要设置下面会说的 <Menu> 标签，这样扩展就不会出现在 PhotoShop 的扩展功能菜单中）

* 自动运行
　<StartOn> 标签下可以添加多个 <Event> 标签，每个 <Event> 标签值为一个事件，当事件发生时，扩展就会被自动打开。
下面这个例子中扩展会在 PhotoShop 启动时自动打开：

```
<Lifecycle>
    <StartOn>
       <Event>applicationActivate</Event>
    </StartOn>
</Lifecycle>
```
关于扩展中的事件（Event）后面会详细说。

<br><br>

#### 4.界面

<UI> 标签下的各种子标签指定关于扩展界面的各种属性

界面类型

<Type> 标签指定扩展界面的显示类型，有 3 中类型：


<Type>Panel</Type>	面板型（Panel）	即普通的工具面板，最为常用
<Type>ModalDialog</Type>	模态对话框（ModalDialog）	把扩展作为一个单独窗口显示，而且在操作扩展的窗口时，是不能操作 PhotoShop 的，必须等扩展窗口关闭后才能继续 PhotoShop。
<Type>Modeless</Type>	非模态对话框（Modeless）	把扩展作为一个单独窗口显示，与模态对话框不同，操作扩展窗口的同时可以随时切换到 PhotoShop 窗口中去。
扩展面板标题
<Menu>Exchange Extension 测试2</Menu>
设置扩展面板的标题，同时也是 PhotoShop 扩展功能菜单列表中的名称。



 

插件尺寸
通过 <Geometry> 标签可以指定扩展面板的大小
分为 <Size>、<MaxSize> 和 <MinSize>，分别是面板默认的初始尺寸、用户能把面板拉伸到的最大和最小尺寸。

 <Geometry>
        <Size>
            <Height>580</Height>
            <Width>1000</Width>
        </Size>
        <MaxSize>
            <Height>800</Height>
            <Width>1200</Width>
        </MaxSize>
        <MinSize>
            <Height>400</Height>
            <Width>600</Width>
        </MinSize>
    </Geometry>
扩展图标
<Icons> 标签的子标签 <Icon> 可以设置扩展的图标，图标有 2 种类型 Normal 和 DarkNormal ，分别在宿主应用的界面主题颜色为亮色和暗色时显示。
另外你可以在 xxx.png 图标文件所在目录放入 xxx@2X.png 文件，在高清屏下 PhotoShop 会调用 xxx@2X.png 文件。一般普通图标的尺寸为 23 x 23 而 xxx@2X.png 为它的 2 倍 46 x 46。

另外还有 RollOver 类型的图标，这是鼠标悬停在图标上时显示的，不过只在 Illustrator 上有效，Photoshop 并不支持。

<Icons>    
    <Icon Type="Normal">./img/icon1.png</Icon>    
    <Icon Type="DarkNormal">./img/icon1.png</Icon>
    <Icon Type="RollOver">./img/IconLight.png</Icon>
    <Icon Type="DarkRollOver">./img/IconDark.png</Icon>
</Icons>



引入第三方库（如 jQuery ）
要注意的是要引入会占用 $ 符号的第三方库如 jQuery ，要在载入前加入一句：window.module = undefined 否则 jQuery 无法把自己注册到 $ 符号，使用  jQuery  时就会出现 $ 未定义的错误，

<script type="text/javascript">window.module = undefined</script>
<script src="js/jquery-2.1.4.min.js" type="text/javascript"></script>
 

 

Node.js
CEP  使用了 Node.js ，而 CEP 6.1 变成了 io.js v1.20 （ 2015-02-10 发布的版本） ，io.js 是一些 Node.js 核心开发者受不了 Node.js 项目迟钝保守管理做风，从而分裂出来的项目，io.js 的更新相对于 Node.js 更活跃，对新特性的更新更积极，而且相对与 Node.js 有相对更好的性能表现。
不过对这个改变，几乎可以预见的是未来 CEP 还会换回 Node.js ，因为 io.js 和 Node.js 从分裂又走向了合并，2 个社区完成了和解，成了了新的基金会，合并成了新的 Node.js 2.0+ 版本。不过对于使用上来说， Node.js 和 io.js 几乎是没有区别的。


io.js 取代了 Node.js
 

开启  Node.js
 

在 CEP 6.1 之前，CEP 是默认开启  Node.js 的，而  CEP 6.1 之后是默认关闭  Node.js 的，需要在 manifest.xml 中 <Resources> 标签下指定开启 Node.js：

...
 <Resources>
     <CEFCommandLine>
          <Parameter>--enable-nodejs</Parameter>
      </CEFCommandLine>
</Resources>
...
而使用 <iframe> 标签组织页面时也需要指定启用 Node.js ,如：

<iframe id="someID"  enable-nodejs></iframe>

